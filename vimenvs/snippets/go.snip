include go_collections.snip
include go_container_list.snip
include go_error.snip
include go_fmt.snip
include go_io.snip
include go_math.snip
include go_os.snip
include go_sort.snip
include go_string.snip
include go_testing.snip
include go_text_template.snip
include go_type.snip

snippet     main
abbr        main
options     word
	package main
	
	import (
		"fmt"
	)
	
	func main() {
		${1}
	}

#
# import
#
snippet     import_multiple
abbr        main
options     word
	import (
		"fmt"
		"math/cmplx"
	)

snippet     import
abbr        main
options     word
	import "${1:fmt}"

#
# for
#
snippet     for_int
abbr        for
options     word
	for ${1:i} := 0; $1 < ${2}; $1++ {
		${0}
	}

delete for
snippet     for
abbr        for
options     word
	for ${1:i := 0}; ${2: i < 10}; ${3:i++} {
		${0}
	}

snippet     for_while
abbr        for
options     word
	sum := 1
	for sum < 1000 {
		sum += sum
	}

snippet     for_infinite
abbr        for
options     word
	for {
	}

#
# if
#
snippet     if_ok
abbr        if
options     word
	if ${1:ret}, ok := ${2:data}; ok {
	}

snippet     if_else
abbr        if
options     word
	if ${1:a < b} {
	} else ${2:a == b} {
	} else {
	}

snippet     if_os
abbr        switch
options     word
	switch ${1:os := runtime.GOOS}; os {
	case "darwin":
		fmt.Println("OS X.")
	case "linux":
		fmt.Println("Linux.")
	default:
		// freebsd, openbsd,
		// plan9, windows...
		fmt.Printf("%s.", os)
	}

#
# const
#
snippet     const
abbr        type
options     word
	const ${1:Name = value}

#
# package
#
snippet     package
abbr        type
options     word
	package main

snippet     package_init
abbr        type
options     word
	func init() {
	
	}

#
# enum
#
snippet     enum_constant
abbr        enum
options     word
	const (
		_          = iota // ignore first value by assigning to blank identifier
		KB float64 = 1 << (10 * iota)
		MB
		GB
		TB
		PB
		EB
		ZB
		YB
	)

#
# var
#
snippet     var_type
abbr        type
options     word
	var ${1:var_name} ${2:TypeName}${3: = 1}

snippet     var_multiple
abbr        type
options     word
	var (
		${1:var_name} ${2:TypeName}${3: = 1}
	)

snippet     var_without_type
abbr        type
options     word
	${1:var_name} := ${3:value}


#
# func
#
snippet     func
abbr        func
options     word
	func ${1:Funcname}(${2:name Type, name Type}) ${3:ReturnType} {
		return result
	}

snippet     func_return_multiple
abbr        func
options     word
	func ${1:Funcname}(${2:name Type, name Type}) ${3:(ReturnType1, error)} {
		return 1
	}

snippet     func_return_named
abbr        func
options     word
	func ${1:Funcname}(${2:name Type, name Type}) ${3:(x ReturnType1, err error)} {
		// x := 1
		// y := 2
		return
	}

snippet     func_method
abbr        func
options     word
	func (${1:recieverName} ${2:RecieverType}) ${3:Funcname}(${4:name Type, name Type}) ${5:ReturnType} {
		return result
	}

snippet     func_method_pointer
abbr        func
options     word
	func (${1:recieverName} *${2:RecieverType}) ${3:Funcname}(${4:name Type, name Type}) ${5:ReturnType} {
		return result
	}

snippet     func_method_pointer_return_none
abbr        func
options     word
	func (${1:recieverName} *${2:RecieverType}) ${3:Funcname}(${4:name Type, err error}) {
		return result
	}

snippet     func_method_stringer
abbr        func
options     word
	func (${1:recieverName} ${2:RecieverType}) String() string {
		return ""
	}

snippet     func_method_immutable
abbr        type
options     word
	func (${1:r RecieverType})${1:Funcname}(${2:name Type, name Type}) ${3:ReturnType} {
		return result
	}

snippet     func_method_mutable
abbr        type
options     word
	func (${1:r RecieverType*})${1:Funcname}(${2:name Type, name Type}) ${3:ReturnType} {
		return result
	}

snippet     func_closure
abbr        closure
options     word
	func ${1:Funcname}(${2:name Type, name Type}) ${3:func(argType) returnType}} {
		return $3 {
		}
	}

#
# interface
#
snippet     interface_def
abbr        interface
options     word
	type ${1:Name} interface {
		${2:MethodName}(${3:val Type}) ${4:ReturnType}
	}

#
# map
#
snippet     map_make_init
abbr        type
options     word
	${1} := map[${2}]${3}{
		${4:key}: ${5:val},
	}

snippet     map_make_init_empty
abbr        type
options     word
	${1} := map[${2}]${3}{}

snippet     map_make
abbr        type
options     word
	${3} := make(map[${1}]${2})

snippet     map_length
abbr        type
options     word
	len(${1:map})

snippet     map_if_contain
abbr        map
options     word
	if val, ok := ${1:mapName}[${2:key}]; ok {
		${0}
	}

snippet     map_if_not_contain
abbr        map
options     word
	if val, ok := ${1:mapName}[${2:key}]; !ok {
		${0}
	}

snippet     map_if_has_key
abbr        map
options     word
	if _, ok := ${1:map}[${2:key}]; ok {
		${0}
	}

snippet     map_for
abbr        for
options     word
	for key, value := range ${1:map} {
	}

snippet     map_get_keys
abbr        for
options     word
	for key, _ := range ${1:map} {
		
	}

snippet     map_delete
abbr        make
options     word
	delete(${1:map}, ${2:key})

snippet     map_get_ok
abbr        make
options     word
	v, ok := ${1:map}[${2:key}]]

snippet     map_make_invert_map
abbr        make
options     word
	${1:intToStr} := map[${2:int32}]${3:string}{}
	for key, value := range ${2:strToInt} {
		$1[value] = key
	}

#
# struct
#
snippet     struct_make
abbr        struct
options     word
	${1:varName} := ${2:StructName}{
		${3:MemberName: memberValue1}
	}

snippet     struct_make_pointer
abbr        struct
options     word
	${1:varName} := &${2:StructName}{
		${3:MemberName: memberValue1}
	}

#
# array
#
snippet     array_make_string
abbr        type
options     word
	${1} := []string{
		"a",
	}

snippet     array_make_int32
abbr        type
options     word
	${1} := []int32{
		1,
	}

snippet     array_make_init
abbr        type
options     word
	${1} := []${2:type}{
	}

snippet     array_make
abbr        type
options     word
	${1} := make([]${2:type}, ${3:length}, ${4:capacity})


snippet     array_for
abbr        make
options     word
	for i, v := range ${1:array} {
		${1}
	}

snippet     array_for_elem
abbr        for
options     word
	for _, elem := range ${1:array} {
		${0}
	}
snippet     array_length
abbr        len
options     word
	len(${1})

snippet     array_capacity
abbr        capacity
options     word
	cap(${1})

snippet     array_for_index
abbr        make
options     word
	for i := 0; i < len(${1:array}); i++ {
		${1}
	}

snippet     array_append
abbr        make
options     word
	${1:array} = append($1, ${2:appendings})

snippet     array_copy
abbr        make
options     word
	b := append([]${1:type}(nil), ${2:array})

snippet     array_cut
abbr        make
options     word
	a = append(${1:array}[:${2:cut_start}], $1[${3:cut_end}:])

snippet     array_cut_without_memory_leak
abbr        make
options     word
	copy(a[i:], a[j:])
	for k, n := len(a)-j+i, len(a); k < n; k++ {
		a[k] = nil // or the zero value of T
	}
	a = a[:len(a)-j+i]

snippet     array_pop
abbr        array
options     word
	${1:elem}, ${2:array} = $2[0], $2[1:]

snippet     array_pop_back
abbr        array
options     word
	${1:elem}, ${2:array} = $2[len($2) - 1], $2[:len($2) - 1]

snippet     array_push_front
abbr        array
options     word
	${1:array} = append([]${2:type}{${3:elem}}, $1)

snippet     array_double
abbr        array
options     word
	${1:array} := make([][]${2:int}, ${3:rowsize})
	for i := 0; i < $3; i++ {
		$1[i] = make([]$2, ${4:colsize})
	}
