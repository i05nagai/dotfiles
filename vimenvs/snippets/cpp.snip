include cpp_algorithm.snip
include cpp_benchmark.snip
include cpp_boost.snip
include cpp_clang_foramt.snip
include cpp_cmath.snip
include cpp_limits.snip
include cpp_preprocessor.snip
include cpp_print.snip
include cpp_random.snip
include cppunit.snip
include doxygen.snip
include gmock.snip
include gtest.snip
include mathjax.snip

delete  template
snippet template
alias   temp
	template <typename ${1}>${0}

delete      namespace2
snippet     namespace2
abbr        namespace { namespace { } }
options     head
	namespace ${1:#:name} { namespace ${2:name} {
		${0:TARGET}
	} } // namespace $1 { namespace $2 {

delete      namespace3
snippet     namespcae3
abbr        namespace { namespace { namespace { } } }
options     head
	namespace ${1:#:name} { namespace ${2:name} { namespace ${3:name} {
		${0:TARGET}
	} } } // namespace $1 { namespace $2 { namespace $3 {

snippet     ifndef2
abbr        #ifndef HOGE...
	#ifndef ${1:HOGE_}_H_INCLUDED
	#define $1_H_INCLUDED
	${0:TARGET}
	#endif // #ifndef $1_H_INCLUDED

snippet     func_free
abbr        void func(...
	${1:void} ${2:func_name}(${3:attr})
	{
		${0}
	}

snippet     func_member
abbr        void className::funcitonName() {}
	${1:void} ${2:class}::${3:function}(${4:attr})
	{
		${0:last}
	}

#
# comment
#
snippet comment
alias   /*
	/* ${1:#:comment} */
	${0}

snippet     comment_separator
abbr        /*--- comment ---*/
	/*--------------------------------------------------------------------------
	* ${0:TARGET}
	*------------------------------------------------------------------------*/

snippet     comment_constructor_destructor
abbr        Constructers and Destructers
	Constructers and Destructer

snippet     comment_member_function
abbr        member functions
	member functions

snippet     comment_pure_virtual_function
abbr        pure virtual functions
	pure virtual functions

snippet     comment_inherited_pure_virtual_function
abbr        inherited pure virtual functions
	inherited pure virtual functions

snippet     comment_private_variable
abbr        private variables 
	private variables

snippet     comment_private_function
abbr        private variables 
	private functions

#
# class
#
delete      class
snippet     class
abbr        class
options     head
	class ${1:name} {
	//private typedef
	private:
	//public typedef
	public:
	//public function
	public:
		${0:end}
	//private function
	private:
	//private members
	private:
	};

delete      struct
snippet     struct
abbr        simple struct
options     head
	struct ${1:name} {
		${0:end}
	};

snippet     vector
abbr        vector
options     word
	std::vector<${1:}> ${2:var}

snippet     vector_of_vector
abbr        vector
options     word
	std::vector<std::vector<${1:}>> ${2:var}

snippet     for_increment_start_with_0_with_size_t
abbr       for (std::size_t index) {}
	for (size_t ${1:index} = 0; $1 < ${2:size}; ++$1) {
		${0}
	}

snippet     for_increment_start_with_0
abbr        for ()
	for (${1:size_t} ${1:index} = 0; $1 < ${2:size}; ++$1) {
		${0}
	}

delete for
snippet     for
abbr        for ()
	for (${1:initil}; ${2:compare}; ${3:post}) {
		${0}
	}

snippet     while
abbr        while () {}
	while (${1:#:condition}) {
		${0:TARGET}
	}

#
# if
#
snippet     if
abbr        if () {}
	if (${1:#:condition}) {
		${0:TARGET}
	}

snippet else
	else {
		${0:TARGET}
	}

snippet elseif
	else if (${1:#:condition}) {
		${0:TARGET}
	}

snippet     ifelse
abbr        if () {} else {}
	if (${1:#:condition}) {
		${2:TARGET}
	} else {
		${3}
	}

snippet     switch
abbr        switch () {}
	switch (${1:#:var}) {
		case ${2:#:val}:
			${0:TARGET}
			break;
	}

snippet     enum
abbr        enum {}
	enum ${1:#:name} {
		${0:TARGET}
	};

# Ternary conditional operator
snippet conditional
	(${1:#:condition}) ? ${2:#:a} : ${3:#:b}

snippet typedef
	typedef ${1:#:base_type} ${2:#:custom_type};

snippet sizeof
alias size
	sizeof(${0:TARGET})

#
# lambda
#
snippet     lambda_capture
abbr        lambda capturing outside variable
options     word
	[&](${1:varDef}) { ${2} }${0:;}

snippet     operator_output
abbr        operator<<
options     word
	std::ostream& operator<<(std::ostream& os, const ${1})
	{
		os << ${2};
		return os;
	}

snippet     write_to_file
abbr        write to file
options     word
	// #include <fstream>
	std::ofstream ${1:file};
	$1.open(${2:path_to_file});
	$1 << "write something";
	$1.close();

snippet     read_from_file
abbr        read from file
options     word
	// #include <fstream>
	std::ifstream ${1:var}(${2:file_name});

#
# template
#
snippet     template_namespace_class
abbr        simple struct
options     word
	#pragma once
	
	namespace ${1:namespace} {
	class ${2:`bufname('%') ==#'[Command Line]' ? expand('#:t:r:r:r') : expand('%:t:r:r:r')`}${3} {
		//private typedef
		private:
		//public typedef
		public:
		//public function
		public:
			${4:end}
		//private function
		private:
		//private members
		private:
	}; // class $2$3 {
	} // namespace $1 {

snippet     template_namespace
abbr        template
options     word
	#include "${1:`bufname('%') ==#'[Command Line]' ? expand('#:t:r:r:r') : expand('%:t:r:r:r')`.h}"
	
	namespace ${2:namespace} {
	  ${0:mfunc}
	} // namespace $2 {

snippet     template_namespace2_class
abbr        template
options     word
	#pragma once
	
	namespace ${1:namespace} { namespace ${2:namespace} {
		class ${3:`bufname('%') ==#'[Command Line]' ? expand('#:t:r:r:r') : expand('%:t:r:r:r')`}${4} {
		//private typedef
		private:
		//public typedef
		public:
		//public function
		public:
			${0:end}
		//private function
		private:
		//private members
		private:
		}; // class $3$4 {
	} } // namespace $1 { namespace $2 {

snippet     template_namespace2
abbr        template
options     word
	#include "${1:`bufname('%') ==#'[Command Line]' ? expand('#:t:r:r:r') : expand('%:t:r:r:r')`.h}"
	
	namespace ${2:namespace} { namespace ${3:namespace} {
		${0:mfunc}
	} } // namespace $2 { namespace $3 {

snippet     template_normal_distribution_cdf
abbr        normal distribution cdf
options     word
	double normal_distribution_cdf(double x)
	{
		// https://www.johndcook.com/blog/cpp_phi/
		// #include <cmath>
		// constants
		const double a1 =  0.254829592;
		const double a2 = -0.284496736;
		const double a3 =  1.421413741;
		const double a4 = -1.453152027;
		const double a5 =  1.061405429;
		const double p  =  0.3275911;
		
		// Save the sign of x
		int sign = 1;
		if (x < 0) {
		sign = -1;
		}
		x = std::fabs(x) / std::sqrt(2.0);
	
		// A&S formula 7.1.26
		const double t = 1.0 / (1.0 + p * x);
		const double y = 1.0 - (((((a5 * t + a4) * t) + a3) * t + a2) * t + a1)
		* t * std::exp(-x * x);
	
		return 0.5 * (1.0 + sign * y);
	}

snippet template_main
alias   main
	int main(int argc, char const* argv[])
	{
		${0:TARGET}
		return 0;
	}
