include sphinx.snip
include python_pytest.snip
include python_matplotlib.snip
include python_pyspark.snip
include python_boto3.snip
include python_faker.snip
include python_mock.snip
include python_pandas.snip
include python_flask.snip

snippet     debug
abbr        import pdb;
options     word
   import pdb; pdb.set_trace() 

snippet     debug_pudb
abbr        from pudb import set_trace; set_trace()
options     word
    from pudb import set_trace; set_trace()

snippet shebang
    #!/usr/bin/env python
    # -*- coding: utf-8 -*-

snippet shebang3
    #!/usr/bin/env python3
    # -*- coding: utf-8 -*-

snippet import
    import ${0:module}

snippet unicode
    def __unicode__(self):
        ${0:representation}

snippet import_from
    from ${1:package} import ${0:module}

# Module Docstring
snippet docs_module
    """
    File: ${1:`vim_snippets#Filename('$1.py', 'foo.py')`}
    Author: `g:snips_author`
    Email: `g:snips_email`
    Github: `g:snips_github`
    Description: ${0}
    """

snippet while
    while ${1:condition}:
        ${0}

snippet do_while
    while True:
        ${1}
        if ${0:condition}:
            break

snippet with
    with ${1:expr} as ${2:var}:
        ${0}

delete with_open
snippet with_open
    with open(${1:filename}, "${2:rwb}") as ${3:f}:
        ${4:pass}

snippet     print_to_file
abbr        print to file
options     word
    def print_to_file(filename, data):
        """print_to_file

        :param filename: 
        :param data:
        """
        with open(filename, "w") as f:
            string = json.dumps(data, indent=4, sort_keys=True)
            f.write(string)

# New Class
snippet cl
    class ${1:ClassName}(${2:object}):
        """${3:docstring for $1}"""
        def __init__(self, ${4:arg}):
            ${5:super($1, self).__init__()}
            self.$4 = $4
            ${0}

# New Function
snippet def
    def ${1:fname}(${2:`indent('.') ? 'self' : ''`}):
        ${0}

# New Method
snippet def_method
    def ${1:mname}(self, ${2:arg}):
        ${0}

# New Property
snippet def_property
    def ${1:foo}():
        doc = "${2:The $1 property.}"
        def fget(self):
            ${3:return self._$1}
        def fset(self, value):
            ${4:self._$1 = value}
        def fdel(self):
            ${0:del self._$1}
        return locals()
    $1 = property(**$1())

# Ifs
snippet if
    if ${1:condition}:
        ${0}
snippet else
    else:
        ${0}

snippet elif
    elif ${1:condition}:
        ${0}

# For
snippet for
    for ${1:item} in ${2:items}:
        ${0}

# Encodes
snippet utf8
    # -*- coding: utf-8 -*-

snippet try_except
    try:
        ${1}
    except ${2:Exception}, ${3:e}:
        ${0:raise $3}

snippet try_except_else
    try:
        ${1}
    except ${2:Exception}, ${3:e}:
        ${4:raise $3}
    else:
        ${0}

snippet try_except_finally
    try:
        ${1}
    except ${2:Exception}, ${3:e}:
        ${4:raise $3}
    finally:
        ${0}

snippet try_except_else_finally
    try:
        ${1}
    except ${2:Exception}, ${3:e}:
        ${4:raise $3}
    else:
        ${5}
    finally:
        ${0}

# if __name__ == '__main__':
snippet main
    if __name__ == '__main__':
        ${0:main()}

snippet """
    """${0:doc}
    """

snippet log
    import logging
    logger = logging.getLogger(${0:__name__})

snippet log_error
    logger.error(${0:msg})

snippet log_debug
    logger.debug(${0:msg})

snippet log_warning
    logger.warning(${0:msg})

snippet log_critical
    logger.critical(${0:msg})

snippet log_info
    logger.info(${0:msg})

snippet     future
abbr        future
options     head
    from __future__ import absolute_import
    from __future__ import division
    from __future__ import print_function
    from __future__ import unicode_literals

## re
snippet     match_with_group
abbr        re.match
options     word
    match_object = re.match(${1:pattern}, ${2:text})
    if match_object:
        ${3:match_object.group(1)}${0}

    
## csv
snippet     csv_write
abbr        csv_write
options     head
    with open("${1:filename}", "w") as f:
        writer = csv.writer(f, lineterminator='\n')
        writer.writerow(list)
        writer.writerows(array2d)

snippet     csv_read
abbr        csv_read
options     head
    with open("${1:filename}", "r") as f:
        reader = csv.reader(f)
        # skip header
        header = next(reader)
        for row in reader:
            row

# date
snippet     datetime_from_string_to_datetime
abbr        datetime_from_string_to_datetime
options     head
    # https://docs.python.org/2.7/library/datetime.html#strftime-and-strptime-behavior
    ${2:date} = datetime.datetime.strptime(${1:date_string}, "%Y-%m-%d %H:%M:%S")

snippet     datetime_from_datetime_to_string
abbr        datetime_from_datetime_to_string
options     head
    # https://docs.python.org/2.7/library/datetime.html#strftime-and-strptime-behavior
    ${2:date_string} = ${1:date}.strftime('%Y/%m/%d')

snippet     datetime_now
abbr        date now
options     head
    datetime.datetime.now()

snippet     datetime_to_date
abbr        datetime to date
options     word
    ${1:datetime_var}.date()${0}

snippet     datetime_from_unixtime_to_datetime
abbr        datetime to date
options     word
    datetime.datetime.fromtimestamp(${1:unixtime})${0}

snippet     datetime_to_unixtime
abbr        datetime to date
options     word
    int(time.mktime(${1:datetime_var}.timetuple()))${0}

snippet     date_now
abbr        date now
options     head
    datetime.datetime.now().date()

snippet     date_to_datetime
abbr        date to datetime
options     word
    ${3:datetime_var} = datetime.datetime.combine(
        ${1:date_var},
        datetime.time().replace(tzinfo=${2:pytz.utc})
    )

snippet     datetime_from_datetime_to_unixtime
abbr        datetime to unixtime
options     word
    # import time
    int(time.mktime(${1:datetime}.timetuple()))

# pprint
snippet     pretty_print_dict
abbr        pretty printer
options     word
    import pprint
    pprint.pprint(${2:dict})${0}

# json
snippet     json_pretty_print
abbr        json pretty print
options     word
    json.dumps(${1}, indent=4, sort_keys=True)${0}

snippet     json_read_from_file
abbr        json read from file
options     word
    json.load(${1:f})${0}

snippet     json_string_to_dict
abbr        json read from file
options     word
    json.loads(${1:string})${0}

# subprocess
snippet     execute_external_command
abbr        execute external_command
options     word
	try:
	    ${2:standard_output} = subprocess.check_output(
	            ${1:command_string},
	            stderr=subprocess.STDOUT,
	            shell=True)
	except subprocess.CalledProcessError as e:
	    print("return code: {0}".format(e.returncode))
	    print("command: {0}".format(e.cmd))
	    print("output: {0}".format(e.output))
	    raise

snippet     execute_external_command_with_stdin
abbr        execute external command with stdin
options     word
	try:
	    p = subprocess.Popen(
	        ${1:command},
	        stdout=subprocess.PIPE,
	        stdin=subprocess.PIPE,
	        stderr=subprocess.PIPE)
	    output, error = p.communicate(input=input_str)
	    if p.returncode != 0:
	        raise RuntimeError(
	            "{0} failed, status code {1} stdout {2} stderr {3}".format(
	                command, p.returncode, output, error))
	    return output
	except OSError as e:
	    print("OSError: ", e.errno)
	    print("OSError: ", e.strerror)
	    print("OSError: ", e.filename)
	    raise

snippet     argument_parser_generate_parser
abbr        generate argument parser
options     word
	import argparse
	
	parser = argparse.ArgumentParser(description="${1:description of program}")
	
	${2:args} = parser.parse_args()

snippet     argument_parser_add_argument
abbr        add argument
options     word
	parser.add_argument("${1:}",
	                    metavar="${2:variable_name}",
	                    type=${3:variable_type},
	                    nargs="+",
	                    help="${5:help message of this argument}")

snippet     argument_sys
abbr        sys.argv
options     word
    # sys.argv[0] is name of scripts
    sys.argv[1]

snippet commandline_argument
    try:
        # Short option syntax: "hv:"
        # Long option syntax: "help" or "verbose="
        opts, args = getopt.getopt(sys.argv[1:], "${1:short_options}", [${2:long_options}])

    except getopt.GetoptError, err:
        # Print debug info
        print str(err)
        ${3:error_action}

    for option, argument in opts:
        if option in ("-h", "--help"):
            ${0}
        elif option in ("-v", "--verbose"):
            verbose = argument

snippet     path_to_this_file
abbr        path to this script
options     word
	import os
	${1:var_name} = os.path.abspath(__file__)${0}

snippet     path_to_this_dir
abbr        path to directori of this script
options     word
	import os
	${1:var_name} = os.path.abspath(os.path.dirname(__file__))${0}

snippet     environment_variable_get
abbr        environment variable
options     head
	import os
	${2:get_var} = os.environ["${1:var_name}"]

snippet     environment_variable_set
abbr        environment variable
options     head
	import os
	os.environ["${1:var_name}"] = ${2:set_var}

snippet     set_add_element
abbr        set add set
options     word
	${1:set_var}.add(${1:list or array}

snippet     set_add_set
abbr        set add set
options     word
	${1:set_var} |= ${2:set_var2}

snippet     if_file_exist
abbr        if file exist
options     word
    import os.path
    os.path.isfile(fname)

snippet     filename_recursively
abbr        files in the directory
options     word
	import os
	for root, subdirs, files in os.walk(${1:rootdir}):
	    for file in files:
	        path_to_file = os.path.join(root, file)

snippet     make_directory_if_not_exists
abbr        make directory
options     head
    # import os
    # import errno
    try:
        os.makedirs(${1:path_to_directory})
    except OSError as e:
        if e.errno != errno.EEXIST:
            raise${0}

snippet     path_file_list
abbr        file list
options     word
    files = os.listdir(${1:path_to_dir})${0}

snippet     path_list_glob
abbr        file list with glob
options     word
    # import glob
    files = glob.glob(${1:path_to_dir})${0}

snippet     path_move
abbr        file rename
options     word
    os.rename(${1:from}, ${2:to})${0}

snippet     path_rename
abbr        replace filename keeping basepath
options     word
    basepath = os.path.basename(${1:path})
    ${2:path}_new = '{0}/${3:new_filename}'.format(basepath)
    os.rename($1, $2)${0}

snippet     path_basename
abbr        file rename
options     word
    os.path.basename(${1:path})${0}

snippet     path_dirname
abbr        dirname of path
options     word
    os.path.dirname(${1:path})${0}

snippet     path_replace_filename
abbr        replace filename keeping basepath
options     word
    basepath = os.path.basename(${1:path})
    ${2:path}_new = '{0}/${3:new_filename}'.format(basepath)

# list
snippet     list_copy
abbr        list copy
options     word
    ${1:var} = ${2:list}[:]

# sort
snippet     sort_list_of_dict_by_elem
abbr        sort list of dict
options     head
    sorted(${1:list}, key=${2:lambda x: x['key']})${0}

snippet     abc_class
abbr        abs class
options     head
    class ${1:class_name}(object):

        __metaclass__ = abc.ABCMeta

        def __init__(self):
            pass

        @abc.abstractmethod
        def ${2:method}(self${3:, attr}):
            raise NotImplemented()

snippet     abc_method
abbr        abs mehod
options     head
        @abc.abstractmethod
        def ${1:method}(self${2:, attr}):
            raise NotImplemented()

snippet     sqlite_connect
abbr        connect
options     word
    conn = sqlite3.connect(${1:path_to_db})

snippet     sqlite_execute
abbr        connect
options     word
    cursor = conn.cursor()
    for row in cursor.execute(${1:query}):
        ${2}

snippet     log_set_output_file
abbr        logging set output file
options     word
    logging.basicConfig(filename=${1:'example.log'}, level=logging.DEBUG)


snippet     func_name
abbr        get function name
options     word
    ${1:function}.__name__
